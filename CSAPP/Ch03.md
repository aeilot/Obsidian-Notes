计算机执行机器代码，用字节序列编码低级操作

Intel 处理器系列俗称 x86

# 程序编码

目标代码（OBJ）$\implies$ 包含所有指令的二进制表示，但是没有填入全局值的地址

指令集体系结构（ISA）定义机器级程序的格式和行为

机器级程序使用的内存地址是虚拟地址

* `%rip` 程序计数器（PC）
* 整数寄存器 
* 条件码寄存器
* 向量寄存器

程序内存包含：程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈、用户分配的内存块

x86-64 的虚拟地址用 64 位的字来表示，目前的实现中，高 16 位地址必须设置成 0

操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址

`gcc -S` 就可以查看汇编代码

`gcc -c` 会编译并汇编代码

![[CSAPP-3th-ZH-OCR.pdf#page=151&rect=9,273,430,418|CSAPP-3th-ZH-OCR, p.151]]

反汇编器可以根据机器代码产生一种类似汇编代码的格式

Linux 中 `objdump -d xxx.o`

> [!NOTE] 注意
> 1. x86-64 指令长度从 1 到 15 个字节不等（常用指令、操作数较少的指令所需子节数少）
> 2. 指令格式：从某个给定位置开始，可以将字节唯一地解码为机器指令
> 3. 反汇编器使用的指令命名规则和 GCC 生成的汇编代码有细微差别

以 `.` 开头的是指导汇编器和链接器工作的伪指令

![[CSAPP-3th-ZH-OCR.pdf#page=154&rect=40,251,462,617|CSAPP-3th-ZH-OCR, p.154]]

C 语言中插入汇编代码，有两种方式：

1. 编写完整的函数，放进一个独立的汇编代码文件中，使用汇编器和链接器合并
2. 使用内联汇编 `asm("...")`

# 数据格式

![[CSAPP-3th-ZH-OCR.pdf#page=155&rect=18,352,442,494|CSAPP-3th-ZH-OCR, p.155]]

汇编指令后缀，表明操作数大小：`movq` `movl`

# 访问信息

x86-64 CPU 中包含 16 个 64 位 通用目的寄存器，命名以 `%r` 开头

![[CSAPP-3th-ZH-OCR.pdf#page=156&rect=65,216,447,660|CSAPP-3th-ZH-OCR, p.156]]

生成小于 8 字节的结果的指令：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节设置为 0

## 操作数指示符

操作数可以分为三种类型：

1. 立即数，表示常数： `$...`，如 `$-577`
2. 寄存器
3. 内存引用，根据计算出来的地址（即有效地址）访问某个内存位置

![[CSAPP-3th-ZH-OCR.pdf#page=157&rect=17,73,432,267|CSAPP-3th-ZH-OCR, p.157]]

例子

![[CSAPP-3th-ZH-OCR.pdf#page=158&rect=155,404,353,559|CSAPP-3th-ZH-OCR, p.158]]

## 数据传送指令

将数据从一个位置复制到另一个位置

MOV 类将数据从原位置复制到目的位置，不做任何变化

![[CSAPP-3th-ZH-OCR.pdf#page=158&rect=117,138,394,241|CSAPP-3th-ZH-OCR, p.158]]

源操作数是一个立即数；目的操作数指定一个位置（内存地址或寄存器）

传送指令的两个操作数不能都指向内存位置；传送指令最后一个字符与操作数大小匹配

传送指令需要两条指令 $\implies$ 加载、写入

特例：`movl` 以寄存器为目的时，会把高位 4 字节设置为 0

`movabsq` 唯一目的是**将一个完整的 64 位（8 字节）立即数（常量）加载到一个 64 位寄存器中**。（常规的 `movq` 只能以表示为 32 位补码数字的立即数作为源操作数）

`MOVZ` 把目的中的剩余字节填充为 0 （零拓展）

`MOVS` 通过符号拓展来填充

![[CSAPP-3th-ZH-OCR.pdf#page=159&rect=21,36,442,316|CSAPP-3th-ZH-OCR, p.159]]

注意： 不存在 `movzlq`，因为 `movl` 即可实现

`cltq` 没有操作

> [!NOTE] MOV 实践
> 1. 指针就是地址
> 2. 局部变量保存在寄存器

函数中 `%rax` 存放返回值

## 压入和弹栈

栈向下生长，栈顶元素地址最低

`%rsp` 栈指针保存栈顶元素地址

![[CSAPP-3th-ZH-OCR.pdf#page=163&rect=48,109,390,206|CSAPP-3th-ZH-OCR, p.163]]

push 减小 `%rsp`

pop 增大 `%rsp`

# 算术和逻辑操作

![[CSAPP-3th-ZH-OCR.pdf#page=165&rect=47,414,405,632|CSAPP-3th-ZH-OCR, p.165]]

## 加载有效地址

load effective address：将有效地址写入到目的操作数（不读取内存，只写地址的值）

可以简洁地描述普通的算术操作

![[CSAPP-3th-ZH-OCR.pdf#page=165&rect=13,40,457,131|CSAPP-3th-ZH-OCR, p.165]]

## 移位操作

只允许单字节寄存器或者立即数作为移位量

## 特殊算术操作

x86-64 指令集对 16 字节的数提供有限支持（16 字节数称为 八字 oct word）

![[CSAPP-3th-ZH-OCR.pdf#page=169&rect=32,216,428,369|CSAPP-3th-ZH-OCR, p.169]]

注意此处的指令时单操作数的

乘法：一个操作数存在 `%rax` 中，结果的高 64 位存在 `%rdx`，低 64 位存在 `%rax`

除法：被除数，高 64 位存在 `%rdx`，低 64 位存在 `%rax`；除数作为操作数；商存在 `%rax`，余数存在 `%rdx`

64 位拓展到 128 位（符号位拓展）：`cqto` 指令 $\implies$ 隐含读取 `%rax` 符号位，复制到 `%rdx` 所有位

# 控制

## 条件码

CPU 维护了一组单个位的条件码寄存器，描述了最近的算术或逻辑操作的属性

![[CSAPP-3th-ZH-OCR.pdf#page=171&rect=15,44,441,106|CSAPP-3th-ZH-OCR, p.171]]

指令一般都会设置条件码

CMP 指令根据两个操作的差来设置条件码 ：相等，零标志设为 1；其他标志可以用来确定两个操作数的大小关系

TEST 指令类似 AND

![[CSAPP-3th-ZH-OCR.pdf#page=172&rect=245,288,472,506|CSAPP-3th-ZH-OCR, p.172]]

## 访问条件码

条件码通常不会直接读取，有一类指令 SET：

 1) 可以根据条件码的某种组合， 将一个字节设置为 0 或者 1
 2) 可以条件跳转到程序的某个其他的部分
 3) 可以有条件地传送数据

![[CSAPP-3th-ZH-OCR.pdf#page=173&rect=50,442,401,663|CSAPP-3th-ZH-OCR, p.173]]

注意：`cmp S D` 是 `D-S`

底层的机器指令可能有多个名字：同义名

## 跳转指令

jmp 无条件跳转；条件跳转，如 je

![[CSAPP-3th-ZH-OCR.pdf#page=175&rect=33,158,424,390|CSAPP-3th-ZH-OCR, p.175]]

### 跳转指令的编码

跳转指令有多种不同编码

最常用的是 PC-relative，将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码

也可以给出绝对地址

`lt_cnt(%rip)` ： 读取全局变量 `lt_cnt` $\implies$ “**`lt_cnt` 这个变量的内存地址**，是通过**相对于 `%rip` (当前指令) 的偏移量**来计算的。”

## if-else

![[CSAPP-3th-ZH-OCR.pdf#page=179&rect=10,405,447,672|CSAPP-3th-ZH-OCR, p.179]]
