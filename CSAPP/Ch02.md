> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=58&selection=75,19,84,32&color=yellow|CSAPP-3th-ZH-OCR, p.58]]
> > 当把位组合在一起，再加上某种解释 (inter pretation) ，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素

无符号：大于等于零的数字，传统的二进制表示法

补码：有符号整数

浮点数：科学计数法，以 2 为基数

数字编码位数有限，结构太大会溢出

# 信息存储

最小的可寻址内存单位：字节 $\implies$ 8 位

虚拟内存：机器级程序将内存视为一个非常大的字节数组

地址：内存的每个字节有一个唯一的数字标识

虚拟地址空间：所有地址的集合

程序对象：程序数据、指令和控制信息

## 十六进制表示法 hex

![[CSAPP-3th-ZH-OCR.pdf#page=61&rect=15,345,439,435&color=yellow|CSAPP-3th-ZH-OCR, p.61]]

 十六进制（Hexadecimal）广泛用于表示二进制数据，因其能简洁地表示字节（每 1 位十六进制对应 4 位二进制）。上表展示了二进制、十进制与十六进制的对应关系。

C 语言中，0x 或 0X 开头的数字常量被认为是十六进制

## 字数据大小
> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=91,0,104,1&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 每台计算机都有一个字长 (word size) ，指明指针数据的标称大小 (nominal size) 。

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=107,12,118,11&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 对于一个字长为 w 位的机器而言，虚拟地址的范围为 0 ～$2^{w}-1$, 程序最多访问 $2^w$ 个字节。
> 

向后兼容：大多数 64 位机器也可以运行 32 位机器编译的程序

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=210,10,221,12&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 我们将程序称为 “32 位程序”或 “64 位程序”时，区别在于该程序是如何编译的， 而不是其运行的机器类型。

![[CSAPP-3th-ZH-OCR.pdf#page=63&rect=210,42,433,282&color=yellow|CSAPP-3th-ZH-OCR, p.63]]

## 寻址与字节顺序

多字节对象被存储为连续的字节序列

对象的地址 $\implies$ 所使用字节中最小的地址

1. 小端法（little endian）：最低有效字节在最前面
2. 大端法（big endian）：最高有效字节在最前面

![[CSAPP-3th-ZH-OCR.pdf#page=65&rect=24,310,446,452|CSAPP-3th-ZH-OCR, p.65]]

双端法（bi-endian）：可以配置为小端法或者大端法

问题：如 不同机器之间网络通信

> 数据类型 `size_t` 表示数据结构大小

## 表示字符串

字符串被编码为一个以 `null` 字符结尾的字符数组

每个字符以某种编码标准（如 ASCII 或 Unicode）表示

## 表示代码

从机器的角度来看，程序仅仅是字节序列

不同的机器类型使用不同且不兼容的指令和编码方式

二进制代码是不兼容的

## 布尔代数

![[CSAPP-3th-ZH-OCR.pdf#page=71&rect=226,278,438,382|CSAPP-3th-ZH-OCR, p.71]]

逻辑符号：∧ (AND), ∨ (OR), ¬ (NOT), ⊕ (XOR)

 把布尔运算扩展到位向量的运算（位向量是固定长度 $w$ 、由 $0$ 和 $1$ 组成的串）

运算性质：

1. `& |` 分配律：`a&(b|c) = (a|b) & (a|c)`
2. `| &` 分配律：`a|(b&c) = (a&b) | (a&c)`
### 布尔环

`a^a=0`

`(a^b)^a=b`

## 逻辑运算

所有非零的参数都表示 `TRUE`，参数 `0` 表示 `FALSE`

如果对第一个参数求值可以确定表达式的结果，不会对第二个参数求值

## 移位运算

### 左移

向左移动 `k` 位，丢弃最高的 `k` 位，右端补 0

### 右移

1. 逻辑右移：左端补 `k` 个 0
2. 算术右移：左端补 `k` 个最高有效位的值

对有符号数，几乎所有编译器/机器进行算术右移

对无符号数，右移必须是逻辑的

# 整数表示
## 无符号数

定义函数 $B2U_{w}$ (Binary to Unsigned, with length w)

![[CSAPP-3th-ZH-OCR.pdf#page=80&rect=67,574,465,636|CSAPP-3th-ZH-OCR, p.80]]

最大值 $2^w-1$ （每一位都是 1）

$B 2U_{w}$ 是一个双射 $\implies$ 无符号数编码唯一性

## 补码编码

补码（two's-complement），定义函数 $B 2T_{w}$ （Binary to Two's-complement）

![[CSAPP-3th-ZH-OCR.pdf#page=81&rect=36,601,440,647|CSAPP-3th-ZH-OCR, p.81]]

最高有效位 $x_{w-1}$ 称为符号位，权重位 $-2^{w-1}$

符号位设置为 $1$ 时，表示值位负；符号位设置为 0 时，表示值非负

最小值 $[1000\dots000]$（$-2^{w-1}$）

最大值 $[0111\dots 111]$ （$2^{w-1} -1$）

补码编码具有唯一性

> 补码的范围是不对称的（最小值没有与之对应的正数）
> 最大的无符号整数值正好比补码的最大值大一点

![[CSAPP-3th-ZH-OCR.pdf#page=83&rect=23,309,430,451|CSAPP-3th-ZH-OCR, p.83]]

![[CSAPP-3th-ZH-OCR.pdf#page=83&rect=22,110,428,216|CSAPP-3th-ZH-OCR, p.83]]

反码和原码：0 有两种不同的编码方式

## 有符号数和无符号数之间的转换

强制类型转换保持位值不变，改变位的解释方式

![[CSAPP-3th-ZH-OCR.pdf#page=85&rect=8,325,289,418|CSAPP-3th-ZH-OCR, p.85]]

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=85&selection=377,0,382,19&color=yellow|CSAPP-3th-ZH-OCR, p.85]]
> > 对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

![[CSAPP-3th-ZH-OCR.pdf#page=86&rect=70,246,467,310&color=yellow|CSAPP-3th-ZH-OCR, p.86]]

当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保待不变

![[CSAPP-3th-ZH-OCR.pdf#page=87&rect=36,304,432,367|CSAPP-3th-ZH-OCR, p.87]]

![[CSAPP-3th-ZH-OCR.pdf#page=87&rect=22,32,440,186|CSAPP-3th-ZH-OCR, p.87]]

## 拓展一个数字的位表示