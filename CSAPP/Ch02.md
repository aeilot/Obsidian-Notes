> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=58&selection=75,19,84,32&color=yellow|CSAPP-3th-ZH-OCR, p.58]]
> > 当把位组合在一起，再加上某种解释 (inter pretation) ，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素

无符号：大于等于零的数字，传统的二进制表示法

补码：有符号整数

浮点数：科学计数法，以 2 为基数

数字编码位数有限，结构太大会溢出

# 信息存储

最小的可寻址内存单位：字节 $\implies$ 8 位

虚拟内存：机器级程序将内存视为一个非常大的字节数组

地址：内存的每个字节有一个唯一的数字标识

虚拟地址空间：所有地址的集合

程序对象：程序数据、指令和控制信息

## 十六进制表示法 hex

![[CSAPP-3th-ZH-OCR.pdf#page=61&rect=15,345,439,435&color=yellow|CSAPP-3th-ZH-OCR, p.61]]

 十六进制（Hexadecimal）广泛用于表示二进制数据，因其能简洁地表示字节（每 1 位十六进制对应 4 位二进制）。上表展示了二进制、十进制与十六进制的对应关系。

C 语言中，0x 或 0X 开头的数字常量被认为是十六进制

## 字数据大小
> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=91,0,104,1&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 每台计算机都有一个字长 (word size) ，指明指针数据的标称大小 (nominal size) 。

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=107,12,118,11&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 对于一个字长为 w 位的机器而言，虚拟地址的范围为 0 ～$2^{w}-1$, 程序最多访问 $2^w$ 个字节。
> 

向后兼容：大多数 64 位机器也可以运行 32 位机器编译的程序

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=210,10,221,12&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 我们将程序称为 “32 位程序”或 “64 位程序”时，区别在于该程序是如何编译的， 而不是其运行的机器类型。

![[CSAPP-3th-ZH-OCR.pdf#page=63&rect=210,42,433,282&color=yellow|CSAPP-3th-ZH-OCR, p.63]]

## 寻址与字节顺序

多字节对象被存储为连续的字节序列

对象的地址 $\implies$ 所使用字节中最小的地址

1. 小端法（little endian）：最低有效字节在最前面
2. 大端法（big endian）：最高有效字节在最前面

![[CSAPP-3th-ZH-OCR.pdf#page=65&rect=24,310,446,452|CSAPP-3th-ZH-OCR, p.65]]

双端法（bi-endian）：可以配置为小端法或者大端法

问题：如 不同机器之间网络通信

> 数据类型 `size_t` 表示数据结构大小

## 表示字符串

字符串被编码为一个以 `null` 字符结尾的字符数组

每个字符以某种编码标准（如 ASCII 或 Unicode）表示

## 表示代码

从机器的角度来看，程序仅仅是字节序列

不同的机器类型使用不同且不兼容的指令和编码方式

二进制代码是不兼容的

## 布尔代数

![[CSAPP-3th-ZH-OCR.pdf#page=71&rect=226,278,438,382|CSAPP-3th-ZH-OCR, p.71]]

逻辑符号：∧ (AND), ∨ (OR), ¬ (NOT), ⊕ (XOR)

 把布尔运算扩展到位向量的运算（位向量是固定长度 $w$ 、由 $0$ 和 $1$ 组成的串）

运算性质：

1. `& |` 分配律：`a&(b|c) = (a|b) & (a|c)`
2. `| &` 分配律：`a|(b&c) = (a&b) | (a&c)`
### 布尔环

`a^a=0`

`(a^b)^a=b`	

## 逻辑运算

所有非零的参数都表示 `TRUE`，参数 `0` 表示 `FALSE`

如果对第一个参数求值可以确定表达式的结果，不会对第二个参数求值

## 移位运算

### 左移

向左移动 `k` 位，丢弃最高的 `k` 位，右端补 0

### 右移

1. 逻辑右移：左端补 `k` 个 0
2. 算术右移：左端补 `k` 个最高有效位的值

对有符号数，几乎所有编译器/机器进行算术右移

对无符号数，右移必须是逻辑的

# 整数表示
## 无符号数

定义函数 $B2U_{w}$ (Binary to Unsigned, with length w)

![[CSAPP-3th-ZH-OCR.pdf#page=80&rect=67,574,465,636|CSAPP-3th-ZH-OCR, p.80]]

最大值 $2^w-1$ （每一位都是 1）

$B 2U_{w}$ 是一个双射 $\implies$ 无符号数编码唯一性

## 补码编码

补码（two's-complement），定义函数 $B 2T_{w}$ （Binary to Two's-complement）

![[CSAPP-3th-ZH-OCR.pdf#page=81&rect=36,601,440,647|CSAPP-3th-ZH-OCR, p.81]]

最高有效位 $x_{w-1}$ 称为符号位，权重位 $-2^{w-1}$

符号位设置为 $1$ 时，表示值位负；符号位设置为 0 时，表示值非负

最小值 $[1000\dots000]$（$-2^{w-1}$）

最大值 $[0111\dots 111]$ （$2^{w-1} -1$）

补码编码具有唯一性

> 补码的范围是不对称的（最小值没有与之对应的正数）
> 最大的无符号整数值正好比补码的最大值大一点

![[CSAPP-3th-ZH-OCR.pdf#page=83&rect=23,309,430,451|CSAPP-3th-ZH-OCR, p.83]]

![[CSAPP-3th-ZH-OCR.pdf#page=83&rect=22,110,428,216|CSAPP-3th-ZH-OCR, p.83]]

反码和原码：0 有两种不同的编码方式

## 有符号数和无符号数之间的转换

强制类型转换保持位值不变，改变位的解释方式

![[CSAPP-3th-ZH-OCR.pdf#page=85&rect=8,325,289,418|CSAPP-3th-ZH-OCR, p.85]]

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=85&selection=377,0,382,19&color=yellow|CSAPP-3th-ZH-OCR, p.85]]
> > 对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

![[CSAPP-3th-ZH-OCR.pdf#page=86&rect=70,246,467,310&color=yellow|CSAPP-3th-ZH-OCR, p.86]]

当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保待不变

![[CSAPP-3th-ZH-OCR.pdf#page=87&rect=36,304,432,367|CSAPP-3th-ZH-OCR, p.87]]

![[CSAPP-3th-ZH-OCR.pdf#page=87&rect=22,32,440,186|CSAPP-3th-ZH-OCR, p.87]]

## 拓展一个数字的位表示

在不同子长的整数之间转换，同时保持数值不变

常见情况：转换为更大的数据类型

### 零拓展

针对于无符号数，在表示的开头添加 `0`

![[CSAPP-3th-ZH-OCR.pdf#page=90&rect=47,471,469,520|CSAPP-3th-ZH-OCR, p.90]]

### 符号拓展

针对补码数字，在表示中添加最高有效位的值

![[CSAPP-3th-ZH-OCR.pdf#page=90&rect=44,361,474,412|CSAPP-3th-ZH-OCR, p.90]]

注意：C 语言标准要求先进行大小改变，再进行有符号到无符号的转换

## 截断数字

截断一个数字，我们直接把高位丢弃，这可能改变它的值，造成溢出

![[CSAPP-3th-ZH-OCR.pdf#page=93&rect=20,539,447,585|CSAPP-3th-ZH-OCR, p.93]]

![[CSAPP-3th-ZH-OCR.pdf#page=93&rect=12,291,449,340|CSAPP-3th-ZH-OCR, p.93]]

**截断相当于取了余数**

对于补码，是按照无符号规则取余数，再按补码规则解释位

## 注意事项

无符号运算容易造成漏洞和错误

# 整数运算

## 无符号加法

![[CSAPP-3th-ZH-OCR.pdf#page=97&rect=34,496,433,558|CSAPP-3th-ZH-OCR, p.97]]

$\to$ 说一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。

![[CSAPP-3th-ZH-OCR.pdf#page=98&rect=53,589,475,634|CSAPP-3th-ZH-OCR, p.98]]

无符号数加法是一种模数加法，构成了阿贝尔群（可交换、可结合）

![[CSAPP-3th-ZH-OCR.pdf#page=98&rect=68,303,475,364|CSAPP-3th-ZH-OCR, p.98]]

## 补码加法

![[CSAPP-3th-ZH-OCR.pdf#page=99&rect=29,526,431,602|CSAPP-3th-ZH-OCR, p.99]]

![[CSAPP-3th-ZH-OCR.pdf#page=101&rect=10,601,443,649|CSAPP-3th-ZH-OCR, p.101]]

## 习题

![[CSAPP-3th-ZH-OCR.pdf#page=101&rect=7,196,434,311|CSAPP-3th-ZH-OCR, p.101]]

> `INT_MIN` - `INT_MAX` = 1
> x = `INT_MAX`, y = `INT_MAX`

![[CSAPP-3th-ZH-OCR.pdf#page=101&rect=9,34,443,184|CSAPP-3th-ZH-OCR, p.101]]

>`-INT_MIN` = `INT_MIN`
> 这在补码运算中符合预期，因为补码的范围是不对称的。
## 补码的非

![[CSAPP-3th-ZH-OCR.pdf#page=102&rect=50,513,471,602|CSAPP-3th-ZH-OCR, p.102]]

`TMIN + TMIN == 0`

## 无符号乘法

![[CSAPP-3th-ZH-OCR.pdf#page=103&rect=35,417,434,467|CSAPP-3th-ZH-OCR, p.103]]

## 补码乘法

![[CSAPP-3th-ZH-OCR.pdf#page=103&rect=29,272,438,320|CSAPP-3th-ZH-OCR, p.103]]

![[CSAPP-3th-ZH-OCR.pdf#page=103&rect=10,165,436,244|CSAPP-3th-ZH-OCR, p.103]]

$\implies$ 可以用除法判断是否溢出

![[CSAPP-3th-ZH-OCR.pdf#page=104&rect=64,42,474,118|CSAPP-3th-ZH-OCR, p.104]]

![[CSAPP-3th-ZH-OCR.pdf#page=105&rect=25,635,435,675|CSAPP-3th-ZH-OCR, p.105]]

## 乘以常数

整数乘法指令相对慢，所以编译器会尝试使用移位和加法运算的组合来代替乘以常数因子的乘法

![[CSAPP-3th-ZH-OCR.pdf#page=106&rect=51,337,476,394|CSAPP-3th-ZH-OCR, p.106]]

与 2 的幂相乘的无符号乘法相当于左移

整数乘以常数可以使用移位、加法和减法的组合来表示

e.g. $3a=(2+1)a$

![[CSAPP-3th-ZH-OCR.pdf#page=107&rect=7,266,445,445|CSAPP-3th-ZH-OCR, p.107]]

## 除法

大多数机器上，整数除法比整数乘法还要慢

整数乘法总是舍入到 0：对于正数，向下舍入；对于负数，向上舍入

除以 2 的幂可以用右移来替代

![[CSAPP-3th-ZH-OCR.pdf#page=108&rect=54,501,478,531|CSAPP-3th-ZH-OCR, p.108]]

![[CSAPP-3th-ZH-OCR.pdf#page=108&rect=51,124,474,170|CSAPP-3th-ZH-OCR, p.108]]

![[CSAPP-3th-ZH-OCR.pdf#page=109&rect=18,353,434,414|CSAPP-3th-ZH-OCR, p.109]]

原理： 相当于向下取整 +1

![[CSAPP-3th-ZH-OCR.pdf#page=109&rect=150,158,385,176|CSAPP-3th-ZH-OCR, p.109]]

![[CSAPP-3th-ZH-OCR.pdf#page=110&rect=47,586,471,636|CSAPP-3th-ZH-OCR, p.110]]

但是，无法用除以 2 的幂的除法来表示常数除法

## 整数总结

1. **计算机整数运算的本质**
    - 实际上是一种模运算形式。
    - 受限于表示数字的有限字长，存在值的取值范围。
    - 运算结果可能会溢出。
2. **补码表示法**
    - 提供了一种灵活的方法，可以同时表示负数和正数。
    - 与无符号算术使用相同的位级实现。
    - 加法、减法、乘法、除法等运算在位级行为上与无符号数完全一样或非常类似。
3. **C 语言中的潜在问题**
    - 某些规定可能会产生令人意想不到的结果。
    - 这些意外结果可能成为难以察觉或理解的缺陷的源头。
    - **`unsigned` 数据类型的陷阱**
        - 概念简单，但可能导致资深程序员都意想不到的行为。
        - 可能以出乎意料的方式出现，例如：            
            - 书写整型常数时。
            - 当调用库函数时。

# 浮点数

浮点表示对形如 $V=x\times{2}^y$ 的有理数进行编码

## 二进制小数

 二进制小数使用类似于十进制小数的表示方法，但基于 2 的幂次方展开

 例如，二进制数 $1.101_2$ 表示的值为：$1 \times 2^0 + 1 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3}$。

![[CSAPP-3th-ZH-OCR.pdf#page=112&rect=236,263,475,487|CSAPP-3th-ZH-OCR, p.112]]

![[CSAPP-3th-ZH-OCR.pdf#page=112&rect=43,137,472,185|CSAPP-3th-ZH-OCR, p.112]]

 某些十进制小数无法被二进制精确表示，导致舍入误差。（小数的二进制表示法只能表示能够写成 $x\times 2^y$ 的数）

## IEEE 浮点表示

$V=(-1)^s\times M \times 2^E$

![[CSAPP-3th-ZH-OCR.pdf#page=114&rect=51,435,476,584|CSAPP-3th-ZH-OCR, p.114]]

float: s (1 bit) + exp (8 bits) + frac (23 bits)

double: s (1 bit) + exp (11 bits) + frac (52 bits)

![[CSAPP-3th-ZH-OCR.pdf#page=114&rect=88,220,432,374|CSAPP-3th-ZH-OCR, p.114]]

![[CSAPP-3th-ZH-OCR.pdf#page=114&rect=67,36,452,188|CSAPP-3th-ZH-OCR, p.114]]

根据 exp 的值，被编码的值有三种不同情况：

### 情况 1: 规格化的值

exp 位模式既不全为 0，又不全为 1

阶码子段被解释为以偏置形式表示的有符号整数：$E=e-Bias$ 

$\to$   $e$ 是无符号数，$Bias=2^{k-1}-1$ ，是一个偏置值

$\implies$ 偏置形式使得数值范围能取到正数和负数：$(0\sim 255) \to (-127\sim +128)$ 

小数字段 frac 被解释为描述小数值 $f$（$0\leq f<1$)，二进制表示为 $0.f_{n-1}\dots f_{1}f_{0}$

尾数定义为 $M = 1 + f$，隐含了前导的 1 （也叫做隐含的以 1 开头的表示）

M 的二进制表示为 $1.f_{n-1}\dots f_{1}f_{0}$

通过调整 E ，可以使 M 范围固定：第一位总是 1，不需要显示的表示出来

### 情况 2：非规格化的值

exp 位模式全为 0

阶码值 $E=1-Bias=2-2^{k-1}$

尾数 $M=f$，就是小数字段的值，不包含隐含的开头 1

非规格化数提供了一种表示 0 的方法

1. +0.0 的位模式全为 0，小数域全为 0，$M=f=0$
2. 类似地，符号位为 1 时，我们得到 -0.0

也可以表示那些非常接近 0 的数，这提供了一种称为逐渐溢出的属性

### 情况 3：特殊值

exp 位模式全为 1

当小数域全为 0 时，得到的数表示无穷：s = 0 时是 $+\infty$ ；s = 1 时是 $-\infty$

$\implies$ 当我们把两个非常大的数相乘，或者除以 0 时，无穷能够表示溢出的结果

当小数域非 0 时，结果值为 NaN （Not a Number）