# extern, static, register

* **`extern`**: 声明一个变量或函数是在别的文件里定义的，目的是为了**跨文件共享**。
* **`static`**: 根据位置有两种意思。
    1.  **函数内部**: 让局部变量的值在函数多次调用之间**保持不变**。
    2.  **函数外部**: 让全局变量或函数的作用域**仅限于当前文件**，其他文件无法访问。
* **`register`**: 建议编译器将变量存入 CPU 寄存器以提速，但现代编译器优化能力很强，通常会**忽略这个关键字**，所以已基本弃用。
# 嵌套复制

从右向左

![[C++程序设计：思想与方法 ideas and methods 慕课.pdf#page=36&rect=47,508,474,589|C++程序设计：思想与方法 ideas and methods 慕课, p.36]]

# cin

读取一个字符： `cin.get()`

# 输出异常

![[C++程序设计：思想与方法 ideas and methods 慕课.pdf#page=72&rect=48,301,408,362|C++程序设计：思想与方法 ideas and methods 慕课, p.72]]

- `cin.eof()`: 返回 `true` 如果已经到达输入流的末尾。
- `cin.fail()`: 返回 `true` 如果发生逻辑错误（例如，尝试读取整数但遇到文本）或更严重的不可恢复错误。这是检查通用输入失败最常用的方法。
- `cin.bad()`: 返回 `true` 如果发生严重的、不可恢复的 I/O 错误（例如，硬件故障）。
# decltype

编译器判断类型

```cpp
int x = 5;
decltype(x) a = 5;
```

```cpp
decltype(auto) max(const auto& a, const auto& b)  {
    return a > b ? a : b;
}
```
# 尾置返回类型

C++11 引入的函数声明语法，使用 `auto` 作为返回类型占位符，并将真正的返回类型放在参数列表之后（由 `->` 引导）。主要用于以下两种场景：

1.  **必需场景**：当返回类型依赖于函数参数时（常见于模板元编程）。
2.  **推荐场景**：当函数返回类型复杂（如函数指针）时，可以提高代码可读性。
#### 语法 (Syntax)

```cpp
// 传统语法
return_type function_name(parameters);

// 尾置返回类型语法
auto function_name(parameters) -> return_type;
```

#### 1. 主要用途：返回类型依赖于函数参数

在模板函数中，返回类型可能由参数类型决定。传统语法无法实现，因为在解析返回类型时，参数还不在作用域内。

```cpp
// 编译失败：在 decltype(t + u) 中，t 和 u 尚未声明
template <typename T, typename U>
decltype(t + u) add(T t, U u);

// 正确：使用尾置返回类型，t 和 u 已经在作用域内
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

#### 2. 提高复杂声明的可读性

当返回类型为函数指针等复杂类型时，尾置返回类型语法更符合从左到右的阅读习惯。

```cpp
// 传统语法：难以阅读
int (*get_operation_function(char op)) (int, int);

// 尾置返回类型：清晰直观
auto get_operation_function(char op) -> int(*)(int, int);
```
# inline 函数、constexpr 函数

1. inline 函数：是向编译器的一个建议，希望它在调用点将函数体展开，以减少函数调用的开销。它在现代 C++ 中更重要的作用是解决头文件中的 ODR (One Definition Rule) 问题，允许多个源文件包含同一个函数定义。
2. constexpr 函数：是对编译器的一个承诺，表示该函数可以在编译期进行求值（当其所有参数都是编译期常量时）。这能将计算从运行时转移到编译期，用于创建真正的编译期常量、优化性能等。
## inline 内联函数
#### 1. 核心理念：减少函数调用开销

当一个函数被调用时，程序需要执行一系列操作：保存当前执行位置、将参数压栈、跳转到函数地址、执行函数体、保存返回值、恢复栈、跳回原执行位置。这个过程会带来一点点性能开销。

对于非常短小且频繁调用的函数，这个开销可能相对显著。inline 关键字就是向编译器提出的一个“内联展开”的建议：

```cpp
// 编译器可能会将 add(a, b) 的调用直接替换为 a + b
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5, y = 10;
    int sum = add(x, y); // 建议编译器将这里替换为：int sum = x + y;
}
```

**重要**：`inline` 只是一个**建议 (hint)**，不是强制命令。编译器会根据自己的优化策略来决定是否进行内联。如果函数体过于复杂（例如包含循环、递归），编译器通常会忽略这个建议。
#### 2. 现代 C++ 中更重要的作用：解决 ODR 问题

C++ 有一条**单一定义规则 (One Definition Rule, ODR)**，即一个变量或函数在一个程序中只能被定义一次。

如果你将一个函数的**定义**放在头文件（`.h`）中，而这个头文件被多个 `.cpp` 文件 `#include`，那么在链接阶段，链接器会发现这个函数有多个定义，从而产生**链接错误 (multiple definition)**。

`inline` 关键字可以解决这个问题。它告诉链接器，这个函数允许有多个相同的定义，只要它们的内容完全一样，链接器就会将它们合并为一。

**因此，`inline` 的主要用途是让你可以在头文件中安全地定义函数，这对于编写仅包含头文件的库 (header-only libraries) 非常关键。**
## constexpr 常量表达式函数
#### 1. 核心理念：在编译期求值

`constexpr` (constant expression) 是 C++11 引入的关键字，它允许函数（或变量）在编译期被求值。

一个 `constexpr` 函数必须满足一些条件（例如，函数体不能太复杂，只能有一个 `return`，不能有副作用等），以保证编译器可以在编译期间计算出其结果。

**关键特性：双重用途** `constexpr` 函数非常灵活，它既可以在编译期使用，也可以在运行时使用。

- **编译期使用**：如果传递给它的所有参数都是编译期常量，那么整个函数调用就会在**编译期间**被计算，结果作为一个纯粹的常量嵌入到代码中。
- **运行时使用**：如果任何一个参数是运行时的变量，那么这个函数就会像一个普通函数一样，在**运行期间**被调用和计算。
#### 2. 为什么需要 `constexpr` 函数？

它的主要收益是将计算从运行时提前到编译期，带来几点好处：

- **性能优化**：免去了运行时的计算开销。
- **定义真正的编译期常量**：可以用它来初始化需要编译期常量的场景，例如 `std::array` 的大小、`enum` 的值、`static_assert` 的条件等。
- **元编程**：可以在编译期执行更复杂的逻辑判断和计算。

```cpp
#include <iostream>
#include <array>

// 一个 constexpr 函数，用于计算阶乘
constexpr long long factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    // 1. 编译期使用
    // factorial(5) 的结果在编译时就被计算为 120
    // 数组的大小必须是编译期常量，这里就可以使用 constexpr 函数
    std::array<int, factorial(5)> my_array; 
    static_assert(factorial(5) == 120, "Factorial calculation failed!");
    std::cout << "Array size: " << my_array.size() << std::endl;

    // 2. 运行时使用
    //因为 num 是一个运行时变量，所以 factorial(num) 也会在运行时被调用
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;
    long long result = factorial(num); // 像普通函数一样在运行时调用
    std::cout << num << "! = " << result << std::endl;

    return 0;
}
```

`constexpr` 函数默认就是 `inline` 的

> [!PDF|yellow] [[C++程序设计：思想与方法 ideas and methods 慕课.pdf#page=96&selection=148,0,154,6&color=yellow|C++程序设计：思想与方法 ideas and methods 慕课, p.96]]
> > 常量表达式函数中只能有一个 return 语句，且不允许有其他执行操作的语句，但可以有类型别名、空语句等
> 

# 模版

C++ 模板是一种创建通用代码的机制，允许我们编写与类型无关的函数或类。通过模板，我们可以实现代码的高度复用而无需牺牲类型安全。模板分为函数模板和类模板两种主要形式。

```cpp
#include <iostream>

// 模板定义
// 'typename T' 定义了一个模板参数 T，T 是一个类型占位符
// 'class' 关键字在这里和 'typename' 是等效的
template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    // 模板的调用与实例化
    // 1. 自动类型推导 (Template Argument Deduction)
    std::cout << "Max of 3, 7 is " << max(3, 7) << std::endl; // T被推导为 int
    std::cout << "Max of 3.14, 2.71 is " << max(3.14, 2.71) << std::endl; // T被推导为 double

    // 2. 显式指定类型
    std::cout << "Max of 3, 7.5 is " << max<double>(3, 7.5) << std::endl; // 显式指定T为double
}
```

## 非类型模版参数

```cpp
// N 是一个在编译期确定的常量
template <typename T, int N>
void print_array(const T (&arr)[N]) {
    std::cout << "Array of size " << N << ": [";
    for (int i = 0; i < N; ++i) {
        std::cout << arr[i] << (i == N - 1 ? "" : ", ");
    }
    std::cout << "]" << std::endl;
}

int main() {
    int my_arr[] = {1, 2, 3, 4, 5};
    print_array(my_arr); // 编译器自动推导出 T=int, N=5
}
```

## 模版的重载

和普通函数一样，函数模板也可以被重载。当有多个函数（模板或非模板）匹配一个调用时，编译器会遵循**最佳匹配原则**：

1. **优先匹配非模板函数**：如果一个普通的非模板函数能完全匹配，编译器会首选它。
2. **其次匹配更特化的模板**：如果多个模板都能匹配，编译器会选择“更特化”（限制更严格）的那个。
3. **最后匹配泛型模板**。

```cpp
#include <iostream>
#include <cstring>

// 1. 最泛化的版本
template <typename T>
const T& max(const T& a, const T& b) {
    std::cout << "Calling generic template max\n";
    return a > b ? a : b;
}

// 2. 一个针对指针的重载模板版本 (更特化)
template <typename T>
const T* max(const T* a, const T* b) {
    std::cout << "Calling pointer template max\n";
    return *a > *b ? a : b;
}

// 3. 一个完全匹配的非模板函数
const char* max(const char* a, const char* b) {
    std::cout << "Calling non-template C-string max\n";
    return std::strcmp(a, b) > 0 ? a : b;
}

int main() {
    max(7, 42); // 调用 1: 泛化模板

    const char* s1 = "hello";
    const char* s2 = "world";
    max(s1, s2); // 调用 3: 非模板函数完全匹配

    int a = 10, b = 20;
    max(&a, &b); // 调用 2: 指针重载版本更特化
}
```

## 模版的显示特化

有时，一个模板的通用定义对于某个特定类型是不适用或效率低下的。这时我们可以为该特定类型提供一个**特化版本**。

例如，通用的 `max` 模板比较 `const char*` 时，只会比较指针地址，而不是字符串内容。我们需要一个特化版本来处理它。

**语法**: `template <> return_type function_name<specialized_type>(...);`

```cpp
// 通用模板
template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

// 针对 const char* 类型的显式特化版本
template <>
const char* max(const char* a, const char* b) {
    return std::strcmp(a, b) > 0 ? a : b;
}

int main() {
    std::cout << max(10, 20) << std::endl; // 调用通用版本
    std::cout << max("apple", "orange") << std::endl; // 调用特化版本
}
```
## 模版的默认类型

```cpp
template<typename T = int>
void f();

f();            // 默认为 f<int>
f<double>();    // 显式指明为 f<double>
```

## 可变参数模版

```cpp
// Args 被称为“模板参数包”
template<typename... Args>
void myFunction(Args... args) { // args 被称为“函数参数包”
    // ... 函数体 ...
}
```

解包可以使用递归或者折叠表达式

```cpp
#include <iostream>

using namespace std;

void print() {
    cout << endl;
}

template <typename T> void print(const T& t) {
    cout << t << endl;
}

template <typename First, typename... Rest> void print(const First& first, const Rest&... rest) {
    cout << first << ", ";
    print(rest...); // recursive call using pack expansion syntax
}

int main()
{
    print(); // calls first overload, outputting only a newline
    print(1); // calls second overload

    // these call the third overload, the variadic template,
    // which uses recursion as needed.
    print(10, 20);
    print(100, 200, 300);
    print("first", 2, "third", 3.14159);
}
```

或者 折叠表达式：

```cpp
template<typename... Args> void print(Args&&... args){ 
	(std::cout << ... << args) << '\n'; 
}
```

```cpp
// 二元右折叠
template<int...I>
constexpr int v = (I + ... + 10);    // 1 + (2 + (3 + (4 + 10)))
// 二元左折叠
template<int...I>
constexpr int v2 = (10 + ... + I);   // (((10 + 1) + 2) + 3) + 4

std::cout << v<1, 2, 3, 4> << '\n';  // 20
std::cout << v2<1, 2, 3, 4> << '\n'; // 20
```
### 折叠表达式的语法

折叠表达式主要有四种形式，可以分为**一元折叠**（Unary Fold）和**二元折叠**（Binary Fold）。

假设我们有一个参数包 `pack` 和一个二元运算符 `op`。

1. **一元右折叠 (Unary right fold)**
    - 语法: `( ... op pack )`
    - 展开形式: `(pack_1 op (pack_2 op ( ... op pack_N)))`
        
2. **一元左折叠 (Unary left fold)**
    - 语法: `( pack op ... )`
    - 展开形式: `(((pack_1 op pack_2) op ... ) op pack_N)`
        
3. **二元右折叠 (Binary right fold)**
    - 语法: `( init op ... op pack )`    
    - 展开形式: `(init op (pack_1 op ( ... op pack_N)))`
    
4. **二元左折叠 (Binary left fold)**
    - 语法: `( pack op ... op init )`
    - 展开形式: `((((init op pack_1) op pack_2) op ... ) op pack_N)`

**关键点:**

- `pack`: 是一个未展开的参数包。 
- `...`: 是展开运算符。
- `op`: 是一个二元运算符，例如 `+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`, `=`, `<`, `>`, `<<`, `>>`, `+=`, `-=`, `&&`, `||`, `,` 等。
- `init`: 是一个初始值。

# string.h

![[C++程序设计：思想与方法 ideas and methods 慕课.pdf#page=131&rect=50,170,489,385&color=yellow|C++程序设计：思想与方法 ideas and methods 慕课, p.131]]

# 指针与常量

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 20;

    // 1. 常量指针 (Pointer to const)
    //-----------------------------------------------------
    // 特点：指针指向的内容不可修改，但指针本身可以修改。
    // 记忆技巧：const在*的左边，修饰的是指针指向的内容(*p)。
    std::cout << "--- 1. 常量指针 (const int *p) ---" << std::endl;
    const int *p1 = &a;

    // *p1 = 30; // 错误！编译不通过。不能通过指针修改所指向的值。
    // error: assignment of read-only location ‘* p1’

    p1 = &b; // 正确。指针p1可以指向另一个地址。
    std::cout << "常量指针p1现在指向的值是: " << *p1 << std::endl; // 输出 20
    std::cout << std::endl;


    // 2. 指针常量 (const Pointer)
    //-----------------------------------------------------
    // 特点：指针本身不可修改，但它指向的内容可以修改。
    // 记忆技巧：const在*的右边，修饰的是指针本身(p)。
    std::cout << "--- 2. 指针常量 (int * const p) ---" << std::endl;
    int* const p2 = &a;

    *p2 = 40; // 正确。可以通过指针修改所指向的值。
    std::cout << "通过指针常量p2修改后, a的值是: " << a << std::endl; // 输出 40

    // p2 = &b; // 错误！编译不通过。指针p2本身是常量，不能再指向其他地址。
    // error: assignment of read-only variable ‘p2’
    std::cout << std::endl;


    // 3. 常量指针常量 (const Pointer to const)
    //-----------------------------------------------------
    // 特点：指针本身和它指向的内容都不可修改。
    // 记忆技巧：*的左右两边都有const。
    std::cout << "--- 3. 常量指针常量 (const int * const p) ---" << std::endl;
    int c = 50;
    const int* const p3 = &c;

    // *p3 = 60; // 错误！编译不通过。不能修改所指向的值。
    // error: assignment of read-only location ‘*(const int*)p3’

    // p3 = &a; // 错误！编译不通过。不能修改指针的指向。
    // error: assignment of read-only variable ‘p3’

    std::cout << "常量指针常量p3指向的值是: " << *p3 << std::endl; // 输出 50
    std::cout << std::endl;


    return 0;
}
```


# 引用

代替指针，更安全

## 右值引用

右值表达式：运算结束后不存在，临时变量，使用后消亡

用 `&&` 表示

移动构造、复制构造、委托构造

![[Pasted image 20251012000605.png]]

![[Pasted image 20251012000620.png]]

# 常量成员函数

```cpp
void display() const;
```

不修改数据成员的函数都应该被声明为 const

常量对象只能调用常量成员函数

# 友元

- **作用**: `friend` 关键字允许一个外部函数或另一个类访问当前类的 `private` 和 `protected` 成员。
- **目的**: 它是一种突破类封装性的机制，用于在特定情况下，为一些紧密相关的类或函数提供必要的访问权限，而无需将成员声明为 `public`。
    
- **核心特点**:
    - **单向性**: 如果类 A 将类 B 声明为友元，意味着 B 可以访问 A 的私有成员，但 A 不能访问 B 的私有成员。
    - **非传递性**: 如果 A 是 B 的友元，B 是 C 的友元，这并不意味着 A 是 C 的友元。
    - **不被继承**: 父类的友元关系不会被子类继承。

- **使用场景**: 最常见的场景是重载操作符（如 `<<` 和 `>>`）和设计一些需要协同工作的紧耦合类（如链表类和节点类）。

# 虚函数

- **虚函数 (`virtual`)**:
    - **目的**: 实现多态。让基类指针或引用在调用成员函数时，能够根据其指向的实际对象类型，来执行派生类中重写的版本。
    - **特点**: 在基类中有实现（可以是空实现），派生类**可以（非必须）**重写 (`override`) 它。
    - **结果**: 基类是具体的，可以被实例化。
        
- **纯虚函数 (`virtual ... = 0`)**:
    - **目的**: 定义一个接口规范。强制所有派生类必须提供该函数的具体实现。
    - **特点**: 在基类中**只有声明没有实现**，以 `= 0` 结尾。
    - **结果**: 包含纯虚函数的类是**抽象基类 (Abstract Base Class)**，不能被实例化。

在现代 C++ 编程中，强烈推荐只要是重写基类的虚函数，就总是使用 `override` 关键字。这是一个非常有用的安全特性，可以大大提高代码的健壮性和可维护性。

另外，C++11 还引入了 `final` 关键字，它可以用来阻止派生类进一步重写某个虚函数，或者阻止一个类被继承。