> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=58&selection=75,19,84,32&color=yellow|CSAPP-3th-ZH-OCR, p.58]]
> > 当把位组合在一起，再加上某种解释 (inter pretation) ，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素

无符号：大于等于零的数字，传统的二进制表示法

补码：有符号整数

浮点数：科学计数法，以 2 为基数

数字编码位数有限，结构太大会溢出

# 信息存储

最小的可寻址内存单位：字节 $\implies$ 8 位

虚拟内存：机器级程序将内存视为一个非常大的字节数组

地址：内存的每个字节有一个唯一的数字标识

虚拟地址空间：所有地址的集合

程序对象：程序数据、指令和控制信息

## 十六进制表示法 hex

![[CSAPP-3th-ZH-OCR.pdf#page=61&rect=15,345,439,435&color=yellow|CSAPP-3th-ZH-OCR, p.61]]

 十六进制（Hexadecimal）广泛用于表示二进制数据，因其能简洁地表示字节（每 1 位十六进制对应 4 位二进制）。上表展示了二进制、十进制与十六进制的对应关系。

C 语言中，0x 或 0X 开头的数字常量被认为是十六进制

## 字数据大小
> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=91,0,104,1&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 每台计算机都有一个字长 (word size) ，指明指针数据的标称大小 (nominal size) 。

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=107,12,118,11&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 对于一个字长为 w 位的机器而言，虚拟地址的范围为 0 ～$2^{w}-1$, 程序最多访问 $2^w$ 个字节。
> 

向后兼容：大多数 64 位机器也可以运行 32 位机器编译的程序

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=63&selection=210,10,221,12&color=yellow|CSAPP-3th-ZH-OCR, p.63]]
> > 我们将程序称为 “32 位程序”或 “64 位程序”时，区别在于该程序是如何编译的， 而不是其运行的机器类型。

![[CSAPP-3th-ZH-OCR.pdf#page=63&rect=210,42,433,282&color=yellow|CSAPP-3th-ZH-OCR, p.63]]

## 寻址与字节顺序

多字节对象被存储为连续的字节序列

对象的地址 $\implies$ 所使用字节中最小的地址

1. 小端法（little endian）：最低有效字节在最前面
2. 大端法（big endian）：最高有效字节在最前面

![[CSAPP-3th-ZH-OCR.pdf#page=65&rect=24,310,446,452|CSAPP-3th-ZH-OCR, p.65]]

双端法（bi-endian）：可以配置为小端法或者大端法

问题：如 不同机器之间网络通信

> 数据类型 `size_t` 表示数据结构大小

## 表示字符串

字符串被编码为一个以 `null` 字符结尾的字符数组

每个字符以某种编码标准（如 ASCII 或 Unicode）表示

## 表示代码

从机器的角度来看，程序仅仅是字节序列

不同的机器类型使用不同且不兼容的指令和编码方式

二进制代码是不兼容的

## 布尔代数

![[CSAPP-3th-ZH-OCR.pdf#page=71&rect=226,278,438,382|CSAPP-3th-ZH-OCR, p.71]]

逻辑符号：∧ (AND), ∨ (OR), ¬ (NOT), ⊕ (XOR)

 把布尔运算扩展到位向量的运算（位向量是固定长度 $w$ 、由 $0$ 和 $1$ 组成的串）

运算性质：

1. `& |` 分配律：`a&(b|c) = (a|b) & (a|c)`
2. `| &` 分配律：`a|(b&c) = (a&b) | (a&c)`
### 布尔环

`a^a=0`

`(a^b)^a=b`	

## 逻辑运算

所有非零的参数都表示 `TRUE`，参数 `0` 表示 `FALSE`

如果对第一个参数求值可以确定表达式的结果，不会对第二个参数求值

## 移位运算

### 左移

向左移动 `k` 位，丢弃最高的 `k` 位，右端补 0

### 右移

1. 逻辑右移：左端补 `k` 个 0
2. 算术右移：左端补 `k` 个最高有效位的值

对有符号数，几乎所有编译器/机器进行算术右移

对无符号数，右移必须是逻辑的

# 整数表示
## 无符号数

定义函数 $B2U_{w}$ (Binary to Unsigned, with length w)

![[CSAPP-3th-ZH-OCR.pdf#page=80&rect=67,574,465,636|CSAPP-3th-ZH-OCR, p.80]]

最大值 $2^w-1$ （每一位都是 1）

$B 2U_{w}$ 是一个双射 $\implies$ 无符号数编码唯一性

## 补码编码

补码（two's-complement），定义函数 $B 2T_{w}$ （Binary to Two's-complement）

![[CSAPP-3th-ZH-OCR.pdf#page=81&rect=36,601,440,647|CSAPP-3th-ZH-OCR, p.81]]

最高有效位 $x_{w-1}$ 称为符号位，权重位 $-2^{w-1}$

符号位设置为 $1$ 时，表示值位负；符号位设置为 0 时，表示值非负

最小值 $[1000\dots000]$（$-2^{w-1}$）

最大值 $[0111\dots 111]$ （$2^{w-1} -1$）

补码编码具有唯一性

> 补码的范围是不对称的（最小值没有与之对应的正数）
> 最大的无符号整数值正好比补码的最大值大一点

![[CSAPP-3th-ZH-OCR.pdf#page=83&rect=23,309,430,451|CSAPP-3th-ZH-OCR, p.83]]

![[CSAPP-3th-ZH-OCR.pdf#page=83&rect=22,110,428,216|CSAPP-3th-ZH-OCR, p.83]]

反码和原码：0 有两种不同的编码方式

## 有符号数和无符号数之间的转换

强制类型转换保持位值不变，改变位的解释方式

![[CSAPP-3th-ZH-OCR.pdf#page=85&rect=8,325,289,418|CSAPP-3th-ZH-OCR, p.85]]

> [!PDF|yellow] [[CSAPP-3th-ZH-OCR.pdf#page=85&selection=377,0,382,19&color=yellow|CSAPP-3th-ZH-OCR, p.85]]
> > 对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

![[CSAPP-3th-ZH-OCR.pdf#page=86&rect=70,246,467,310&color=yellow|CSAPP-3th-ZH-OCR, p.86]]

当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保待不变

![[CSAPP-3th-ZH-OCR.pdf#page=87&rect=36,304,432,367|CSAPP-3th-ZH-OCR, p.87]]

![[CSAPP-3th-ZH-OCR.pdf#page=87&rect=22,32,440,186|CSAPP-3th-ZH-OCR, p.87]]

## 拓展一个数字的位表示

在不同子长的整数之间转换，同时保持数值不变

常见情况：转换为更大的数据类型

### 零拓展

针对于无符号数，在表示的开头添加 `0`

![[CSAPP-3th-ZH-OCR.pdf#page=90&rect=47,471,469,520|CSAPP-3th-ZH-OCR, p.90]]

### 符号拓展

针对补码数字，在表示中添加最高有效位的值

![[CSAPP-3th-ZH-OCR.pdf#page=90&rect=44,361,474,412|CSAPP-3th-ZH-OCR, p.90]]

注意：C 语言标准要求先进行大小改变，再进行有符号到无符号的转换

## 截断数字

截断一个数字，我们直接把高位丢弃，这可能改变它的值，造成溢出

![[CSAPP-3th-ZH-OCR.pdf#page=93&rect=20,539,447,585|CSAPP-3th-ZH-OCR, p.93]]

![[CSAPP-3th-ZH-OCR.pdf#page=93&rect=12,291,449,340|CSAPP-3th-ZH-OCR, p.93]]

**截断相当于取了余数**

对于补码，是按照无符号规则取余数，再按补码规则解释位

## 注意事项

无符号运算容易造成漏洞和错误

# 整数运算

## 无符号加法

![[CSAPP-3th-ZH-OCR.pdf#page=97&rect=34,496,433,558|CSAPP-3th-ZH-OCR, p.97]]

$\to$ 说一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。

![[CSAPP-3th-ZH-OCR.pdf#page=98&rect=53,589,475,634|CSAPP-3th-ZH-OCR, p.98]]

无符号数加法是一种模数加法，构成了阿贝尔群（可交换、可结合）

![[CSAPP-3th-ZH-OCR.pdf#page=98&rect=68,303,475,364|CSAPP-3th-ZH-OCR, p.98]]

## 补码加法

![[CSAPP-3th-ZH-OCR.pdf#page=99&rect=29,526,431,602|CSAPP-3th-ZH-OCR, p.99]]

![[CSAPP-3th-ZH-OCR.pdf#page=101&rect=10,601,443,649|CSAPP-3th-ZH-OCR, p.101]]

## 习题

![[CSAPP-3th-ZH-OCR.pdf#page=101&rect=7,196,434,311|CSAPP-3th-ZH-OCR, p.101]]

> `INT_MIN` - `INT_MAX` = 1
> x = `INT_MAX`, y = `INT_MAX`

![[CSAPP-3th-ZH-OCR.pdf#page=101&rect=9,34,443,184|CSAPP-3th-ZH-OCR, p.101]]

>`-INT_MIN` = `INT_MIN`
> 这在补码运算中符合预期，因为补码的范围是不对称的。
## 补码的非

![[CSAPP-3th-ZH-OCR.pdf#page=102&rect=50,513,471,602|CSAPP-3th-ZH-OCR, p.102]]

`TMIN + TMIN == 0`

## 无符号乘法

![[CSAPP-3th-ZH-OCR.pdf#page=103&rect=35,417,434,467|CSAPP-3th-ZH-OCR, p.103]]

## 补码乘法

![[CSAPP-3th-ZH-OCR.pdf#page=103&rect=29,272,438,320|CSAPP-3th-ZH-OCR, p.103]]

![[CSAPP-3th-ZH-OCR.pdf#page=103&rect=10,165,436,244|CSAPP-3th-ZH-OCR, p.103]]

$\implies$ 可以用除法判断是否溢出

![[CSAPP-3th-ZH-OCR.pdf#page=104&rect=64,42,474,118|CSAPP-3th-ZH-OCR, p.104]]

![[CSAPP-3th-ZH-OCR.pdf#page=105&rect=25,635,435,675|CSAPP-3th-ZH-OCR, p.105]]

## 乘以常数

整数乘法指令相对慢，所以编译器会尝试使用移位和加法运算的组合来代替乘以常数因子的乘法

![[CSAPP-3th-ZH-OCR.pdf#page=106&rect=51,337,476,394|CSAPP-3th-ZH-OCR, p.106]]

与 2 的幂相乘的无符号乘法相当于左移

整数乘以常数可以使用移位、加法和减法的组合来表示

e.g. $3a=(2+1)a$

![[CSAPP-3th-ZH-OCR.pdf#page=107&rect=7,266,445,445|CSAPP-3th-ZH-OCR, p.107]]

## 除法

大多数机器上，整数除法比整数乘法还要慢

整数乘法总是舍入到 0：对于正数，向下舍入；对于负数，向上舍入

除以 2 的幂可以用右移来替代

![[CSAPP-3th-ZH-OCR.pdf#page=108&rect=54,501,478,531|CSAPP-3th-ZH-OCR, p.108]]

![[CSAPP-3th-ZH-OCR.pdf#page=108&rect=51,124,474,170|CSAPP-3th-ZH-OCR, p.108]]

![[CSAPP-3th-ZH-OCR.pdf#page=109&rect=18,353,434,414|CSAPP-3th-ZH-OCR, p.109]]

原理： 相当于向下取整 +1

![[CSAPP-3th-ZH-OCR.pdf#page=109&rect=150,158,385,176|CSAPP-3th-ZH-OCR, p.109]]

![[CSAPP-3th-ZH-OCR.pdf#page=110&rect=47,586,471,636|CSAPP-3th-ZH-OCR, p.110]]

但是，无法用除以 2 的幂的除法来表示常数除法

## 整数总结

1. **计算机整数运算的本质**
    - 实际上是一种模运算形式。
    - 受限于表示数字的有限字长，存在值的取值范围。
    - 运算结果可能会溢出。
2. **补码表示法**
    - 提供了一种灵活的方法，可以同时表示负数和正数。
    - 与无符号算术使用相同的位级实现。
    - 加法、减法、乘法、除法等运算在位级行为上与无符号数完全一样或非常类似。
3. **C 语言中的潜在问题**
    - 某些规定可能会产生令人意想不到的结果。
    - 这些意外结果可能成为难以察觉或理解的缺陷的源头。
    - **`unsigned` 数据类型的陷阱**
        - 概念简单，但可能导致资深程序员都意想不到的行为。
        - 可能以出乎意料的方式出现，例如：            
            - 书写整型常数时。
            - 当调用库函数时。

# 浮点数

浮点表示对形如 $V=x\times{2}^y$ 的有理数进行编码（IEEE 754 标准）

## 二进制小数

 二进制小数使用类似于十进制小数的表示方法，但基于 2 的幂次方展开

 例如，二进制数 $1.101_2$ 表示的值为：$1 \times 2^0 + 1 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3}$。

![[CSAPP-3th-ZH-OCR.pdf#page=112&rect=236,263,475,487|CSAPP-3th-ZH-OCR, p.112]]

![[CSAPP-3th-ZH-OCR.pdf#page=112&rect=43,137,472,185|CSAPP-3th-ZH-OCR, p.112]]

 某些十进制小数无法被二进制精确表示，导致舍入误差。（小数的二进制表示法只能表示能够写成 $x\times 2^y$ 的数）

## IEEE 754 浮点表示

$V=(-1)^s\times M \times 2^E$

![[CSAPP-3th-ZH-OCR.pdf#page=114&rect=51,435,476,584|CSAPP-3th-ZH-OCR, p.114]]

float: s (1 bit) + exp (8 bits) + frac (23 bits)

double: s (1 bit) + exp (11 bits) + frac (52 bits)

![[CSAPP-3th-ZH-OCR.pdf#page=114&rect=88,220,432,374|CSAPP-3th-ZH-OCR, p.114]]

![[CSAPP-3th-ZH-OCR.pdf#page=114&rect=67,36,452,188|CSAPP-3th-ZH-OCR, p.114]]

根据 exp 的值，被编码的值有三种不同情况：

### 情况 1: 规格化的值

exp 位模式既不全为 0，又不全为 1

阶码子段被解释为以偏置形式表示的有符号整数：$E=e-Bias$ 

$\to$   $e$ 是无符号数，$Bias=2^{k-1}-1$ ，是一个偏置值

$\implies$ 偏置形式使得数值范围能取到正数和负数：$(0\sim 255) \to (-127\sim +128)$ 

小数字段 frac 被解释为描述小数值 $f$（$0\leq f<1$)，二进制表示为 $0.f_{n-1}\dots f_{1}f_{0}$

尾数定义为 $M = 1 + f$，隐含了前导的 1 （也叫做隐含的以 1 开头的表示）

M 的二进制表示为 $1.f_{n-1}\dots f_{1}f_{0}$

通过调整 E ，可以使 M 范围固定：第一位总是 1，不需要显示的表示出来

### 情况 2：非规格化的值

exp 位模式全为 0

阶码值 $E=1-Bias=2-2^{k-1}$

这样设置阶码可以实现非规格化值与规格化值的平滑转变

尾数 $M=f$，就是小数字段的值，不包含隐含的开头 1

非规格化数提供了一种表示 0 的方法

1. +0.0 的位模式全为 0，小数域全为 0，$M=f=0$
2. 类似地，符号位为 1 时，我们得到 -0.0

也可以表示那些非常接近 0 的数，这提供了一种称为逐渐溢出的属性

### 情况 3：特殊值

exp 位模式全为 1

当小数域全为 0 时，得到的数表示无穷：s = 0 时是 $+\infty$ ；s = 1 时是 $-\infty$

$\implies$ 当我们把两个非常大的数相乘，或者除以 0 时，无穷能够表示溢出的结果

当小数域非 0 时，结果值为 NaN （Not a Number）

这种表示方式，如果位表达式解释为无符号整数，对于非负数，是升序排序的（负数则是降序排序）

## 舍入

表示方式限制了浮点数的范围和精度 $\implies$ 浮点运算是对实数的近似

IEEE 浮点格式定义了四种舍入方式

1. 向偶数舍入（向最接近的值舍入）：将数字向上或向下舍入，使得结果的最低有效数字是偶数
2. 向零舍入（正数向下，负数向上）
3. 向下舍入
4. 向上舍入

向偶数舍入是默认的舍入方式

这种方式会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中是以 0 结尾的）

这样会使得在两个数中间的数，50% 的时间向上舍入，50% 的时间向下舍入，避免平均值统计偏差

## 浮点运算

IEEE 标准将浮点运算简单地定义为实数运算后舍入

当参数中有一个是特殊值时，定义了一些特殊的规则：如 $\frac{1}{-0}=-\infty$

### 浮点运算缺乏的数学性质

#### 1. 浮点加法 ($x+^f y$)

- **缺乏结合性（Associativity）:**
    - **定义:** 在实数中，$(a+b)+c = a+(b+c)$ 恒成立。
    - **浮点数中:** 不成立。这是因为每一步加法都可能进行舍入（取近似值），而结合顺序改变了舍入发生的时刻和数值。
    - 例子: 在单精度浮点数下：

    $$\mathbf{3.14 + (1e10 - 1e10)} \text{ 求值为 } \mathbf{3.14}$$

    $$\mathbf{(3.14 + 1e10) - 1e10} \text{ 求值为 } \mathbf{0.0}$$

        （原因：在第二种情况下， 3.14+1e10 时，3.14 相对于 1e10 精度太低，被舍入损失，导致结果为 1e10，再减去 1e10 得到 0.0）。
    - **编译器优化问题:** 编译器在优化时可能改变加法的顺序（如将 `a+b+c+d` 重排），如果浮点加法不具有结合性，这种优化就可能导致结果与原始代码不同。
#### 2. 浮点乘法 ($x*^f y$)

- **缺乏结合性（Associativity）:**

    - 例子: 在单精度浮点数下：    $$\mathbf{(1e20 * 1e20) * 1e-20} \text{ 求值为 } \mathbf{+\infty}$$

        （原因：1e20∗1e20=1e40，超出了单精度浮点数的最大范围，发生溢出，结果为无穷大 ∞；∞∗1e−20 仍是 ∞）。

        $$\mathbf{1e20 * (1e20 * 1e-20)} \text{ 结果为 } \mathbf{1e20}$$

        （原因：1e20∗1e−20=1.0；1e20∗1.0=1e20）。

    - 这说明结合顺序改变了是否发生溢出的时机，导致结果差异巨大。  
- **缺乏分配性（Distributivity）:**
    - **定义:** 在实数中，$a \times (b+c) = a \times b + a \times c$ 恒成立。 
    - **浮点数中:** 不成立。
    - 例子: 在单精度浮点数下：

        $$\mathbf{1e20 * (1e20 - 1e20)} \text{ 求值为 } \mathbf{0.0}$$

        $$\mathbf{1e20 * 1e20 - 1e20 * 1e20} \text{ 结果为 } \mathbf{NaN}$$

        （原因：1e20∗1e20 两次都发生溢出，得到 ∞；∞−∞ 的结果在 IEEE 754 中定义为 NaN (非数)）。

### 第二部分：浮点运算的良好性质

尽管浮点运算缺乏一些数学性质，但浮点运算仍满足一些基本数学性质：

1. **封闭性（Closure）:** 乘法运算是封闭的，意味着两个有限浮点数相乘，结果要么是一个有限浮点数，要么是 $\infty$（溢出），要么是 $0$（下溢），或者是 **NaN**（如 $0 \times \infty$），不会产生定义之外的数。
2. 可交换性（Commutativity）: 浮点乘法满足可交换性：

    $$a *^f b = b *^f a$$

3. 单位元（Identity Element）: 1.0 是乘法的单位元：

    $$a *^f 1.0 = a$$

4. **单调性（Monotonicity）:** 浮点和加法乘法具有单调性（只要 $a, b, c$ 都不是 NaN，且 $a, b$ 不为 $\pm\infty$），而整数不具有这个性质（溢出）
	1. NaN + a = NaN
### 总结对程序员和编译器的影响

- **缺乏结合性和分配性**对科学计算程序员和编译器编写者来说是**非常严重的问题**。
- **对于程序员:** 必须时刻注意运算顺序、精度损失和溢出，避免依赖结合律和分配律编写代码。
- **对于编译器:** 编译器在进行优化（例如，改变运算顺序以提高效率）时，必须考虑到浮点数的这些性质缺陷。如果编译器不遵循严格的顺序，结果可能会与用户预期的不同，这在需要高精度和确定性（如几何、物理模拟）的应用中是一个巨大的挑战。
## C 语言中的浮点数

![[CSAPP-3th-ZH-OCR.pdf#page=122&rect=40,41,473,242|CSAPP-3th-ZH-OCR, p.122]]
